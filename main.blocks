<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id=";eB=Sz:tu?1q#~6r|SBZ">strip</variable><variable id="%a~FTm]a1~TAbAqHn:iC">strip2</variable></variables><block type="variables_set" id=")f|u(itd3i7s9ln7BbZl" disabled="true" x="-291" y="-256"><field name="VAR" id=";eB=Sz:tu?1q#~6r|SBZ">strip</field><value name="VALUE"><shadow xmlns="http://www.w3.org/1999/xhtml" type="math_number"><field name="NUM">0</field></shadow><block type="neopixel_create" id="23Rcy-.#oJASHU8sJ-Uw" disabled="true"><field name="pin">DigitalPin.P0</field><value name="numleds"><shadow type="math_number" id="foO,#o7p+ke8@=YZ1[EQ" disabled="true"><field name="NUM">24</field></shadow></value></block></value></block><block type="variables_set" id=":x^d.,9^ae,,*4w/Q=zY" disabled="true" x="-75" y="-109"><field name="VAR" id="%a~FTm]a1~TAbAqHn:iC">strip2</field><value name="VALUE"><shadow xmlns="http://www.w3.org/1999/xhtml" type="math_number"><field name="NUM">0</field></shadow><block type="neopixel_create" id="*maM`xCElQ%hnTv)HDTw" disabled="true"><field name="pin">DigitalPin.P0</field><value name="numleds"><shadow type="math_number" id="pWs?f(VHQuKTx;8lGz[0" disabled="true"><field name="NUM">24</field></shadow></value></block></value></block><block type="pxt-on-start" id="}=3i|E[zc4O?D)kg0Pni" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="AuvhSNB~Mcd2+BG${?%2" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="declare const enum LEDToRead {" line1="    //% block=&quot;Red&quot; enumval=1" line2="    Red = 1," line3="    //% block=&quot;Infrared&quot; enumval=2" line4="    Infrared = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="kT+x?Sf8mYMjbTkbLZsr" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="declare const enum HeartbeatType {" line1="    //% block=&quot;BPM&quot; enumval=0" line2="    BPM = 0," line3="    //% block=&quot;AVG&quot; enumval=1" line4="    AVG = 1," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="aO@Ag)oM@sO)q[ydF8^Q" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="declare const enum LEDMode {" line1="    //% block=&quot;Red&quot; enumval=2" line2="    RedLED = 2," line3="    //% block=&quot;Red &amp; Infrared&quot; enumval=3" line4="    RedAndIR = 3," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="i`;?LPk2E/JFHyT!{ea|" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum PingUnit {" line1="    //% block=&quot;微秒&quot;" line2="    MicroSeconds," line3="    //% block=&quot;厘米&quot;" line4="    Centimeters," line5="    //% block=&quot;英寸&quot;" line6="    Inches" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="771tABVnEd@%.GrlMoby" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum PINs {" line1="    P0," line2="    P1," line3="    P2," line4="    P3," line5="    P4," line6="    P5," line7="    P6," line8="    P7," line9="    P8," line10="    P9," line11="    P10," line12="    P11," line13="    P12," line14="    P13," line15="    P14," line16="    P15," line17="    P16," line18="    P19," line19="    P20" line20="}" numlines="21"></mutation><next><block type="typescript_statement" id=")vyDa$)|[=TtCzuuM,e!" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum TMP36Type {" line1="    //% block=&quot;(℃)&quot; enumval=0" line2="    TMP36_temperature_C," line3="" line4="    //% block=&quot;(℉)&quot; enumval=1" line5="    TMP36_temperature_F," line6="}" numlines="7"></mutation><next><block type="typescript_statement" id="gKOQOm,6@pSeEv%=a`OP" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum RGB {" line1="    //% block=&quot;红&quot;" line2="    RED," line3="    //% block=&quot;绿&quot;" line4="    GREEN," line5="    //% block=&quot;蓝&quot;" line6="    BLUE," line7="    //% block=&quot;全部&quot;" line8="    CLEAR" line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="vo/SKTYs%=]Ig-:FzVfk" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum NeoPixelColors {" line1="    //% block=红" line2="    Red = 0xFF0000," line3="    //% block=橙" line4="    Orange = 0xFFA500," line5="    //% block=黄" line6="    Yellow = 0xFFFF00," line7="    //% block=绿" line8="    Green = 0x00FF00," line9="    //% block=蓝" line10="    Blue = 0x0000FF," line11="    //% block=靛蓝" line12="    Indigo = 0x4b0082," line13="    //% block=紫罗兰" line14="    Violet = 0x8a2be2," line15="    //% block=紫" line16="    Purple = 0xFF00FF," line17="    //% block=白" line18="    White = 0xFFFFFF," line19="    //% block=黑" line20="    Black = 0x000000" line21="}" numlines="22"></mutation><next><block type="typescript_statement" id="96X4Pv/.FYB6X^9~Lcnb" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum NeoPixelMode {" line1="    //% block=&quot;RGB (GRB 格式)&quot;" line2="    RGB = 1," line3="    //% block=&quot;RGB+W&quot;" line4="    RGBW = 2," line5="    //% block=&quot;RGB (RGB 格式)&quot;" line6="    RGB_RGB = 3" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="Fzj/9y.$wd_T2Ffs9d=#" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Microbit {" line1="" line2="    export enum DHT11_state {" line3="        //% block=&quot;温度(℃)&quot; enumval=0" line4="        DHT11_temperature_C," line5="" line6="        //% block=&quot;湿度(0~100)&quot; enumval=1" line7="        DHT11_humidity," line8="    }" line9="" line10="    export enum Distance_Unit_List {" line11="        //% block=&quot;厘米&quot; " line12="        Distance_Unit_cm," line13="" line14="        //% block=&quot;英寸&quot;" line15="        Distance_Unit_inch," line16="    }" line17="" line18="" line19="" line20="" line21="" line22="" line23="    //% weight=30 " line24="    //% blockId=&quot;gatorParticle_begin&quot; " line25="    //% block=&quot;心率血氧传感器初始化&quot;" line26="    //% group=&quot;心率血氧传感器&quot; subcategory=传感器" line27="    //% shim=gatorParticle::begin" line28="    export function begin() {" line29="        return" line30="    }" line31="" line32="    /**" line33="    * Reads either the Red or Infrared detection channels.." line34="    */" line35="    //% weight=29 " line36="    //% blockId=&quot;gatorParticle_color&quot; " line37="    //% block=&quot;获取 %LEDToRead 值&quot;" line38="    //% group=&quot;心率血氧传感器&quot; subcategory=传感器" line39="    //% shim=gatorParticle::color" line40="    export function color(type: LEDToRead): number {" line41="        return 0" line42="    }" line43="" line44="    /**" line45="    * Set which LED's we want the sensor to update and read." line46="    */" line47="    //% weight=28" line48="    //% blockId=&quot;gatorParticle_setReadMode&quot;" line49="    //% block=&quot;设置LED的读取模式 %LEDMode&quot;" line50="    //% group=&quot;心率血氧传感器&quot; subcategory=传感器" line51="    //% shim=gatorParticle::setReadMode" line52="    " line53="    export function setReadMode(mode: LEDMode) {" line54="        return" line55="    }" line56="" line57="    /**" line58="    * Set the amplitude of either Red or Infrared LED" line59="    */" line60="    //% weight=27" line61="    //% blockId=&quot;gatorParticle_setAmplitude&quot;" line62="    //% block=&quot;将强度从 %LEDToRead | 设置为 %myBrightness&quot;" line63="    //% group=&quot;心率血氧传感器&quot; subcategory=传感器" line64="    //% shim=gatorParticle::setAmplitude" line65="    " line66="    export function setAmplitude(led: LEDToRead, myBrightness: number) {" line67="        return" line68="    }" line69="" line70="    /**" line71="    * Grab the heartbeat from the sensor in either beats per minute, or an average of the last 4 BPM readings." line72="    */" line73="    //% weight=26" line74="    //% blockId=&quot;gatorParticle_heartbeat&quot;" line75="    //% block=&quot;设置心跳检测方式为%HeartbeatType&quot;" line76="    //% group=&quot;心率血氧传感器&quot; subcategory=传感器" line77="    //% shim=gatorParticle::heartbeat" line78="    export function heartbeat(type: HeartbeatType): number {" line79="        return 0" line80="    }" line81="    " line82="" line83="" line84="" line85="" line86="" line87="" line88="    //% blockId=&quot;readsoilmoisture&quot; block=&quot;土壤湿度传感器 %soilhumiditypin&quot;" line89="    //% subcategory=传感器" line90="    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {" line91="        let voltage = 0;" line92="        let soilmoisture = 0;" line93="        voltage = pins.map(" line94="            pins.analogReadPin(soilmoisturepin)," line95="            0," line96="            1023," line97="            0," line98="            1023" line99="        );" line100="        soilmoisture = voltage;" line101="        return Math.round(soilmoisture);" line102="    }" line103="    //% blockId=&quot;readlightintensity&quot; block=&quot;光敏传感器 %lightintensitypin&quot;" line104="    //% subcategory=传感器" line105="    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {" line106="        let voltage2 = 0;" line107="        let lightintensity = 0;" line108="        voltage2 = pins.map(" line109="            pins.analogReadPin(lightintensitypin)," line110="            0," line111="            1023," line112="            0," line113="            1023" line114="        );" line115="        lightintensity = voltage2;" line116="        return Math.round(1023 - lightintensity);" line117="    }" line118="    /**" line119="    * toggle fans" line120="    */" line121="    //% blockId=fans block=&quot;电机风扇 %pin 切换至 $fanstate || 速度 %speed&quot;" line122="    //% fanstate.shadow=&quot;toggleOnOff&quot;" line123="    //% speed.min=0 speed.max=1023" line124="    //% expandableArgumentMode=&quot;toggle&quot;" line125="    //% subcategory=执行器" line126="    export function motorFan(pin: AnalogPin, fanstate: boolean, speed: number = 1023): void {" line127="        if (fanstate) {" line128="            pins.analogSetPeriod(pin, 1023)" line129="            pins.analogWritePin(pin, Math.map(speed, 0, 1023, 0, 1023))" line130="        }" line131="        else {" line132="            pins.analogWritePin(pin, 0)" line133="            speed = 0" line134="        }" line135="    }" line136="" line137="    /**" line138="    * get Ultrasonic distance" line139="    */" line140="    //% blockId=sonarbit" line141="    //% distance_unit.fieldEditor=&quot;gridpicker&quot;" line142="    //% distance_unit.fieldOptions.columns=2" line143="    //% subcategory=传感器" line144="    //% blockId=sonar_ping block=&quot;超声波传感器 echo %echo trig %trig 单位 %unit&quot;" line145="    export function ping(trig: DigitalPin, echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {" line146="        // send pulse" line147="        pins.setPull(trig, PinPullMode.PullNone);" line148="        pins.digitalWritePin(trig, 0);" line149="        control.waitMicros(2);" line150="        pins.digitalWritePin(trig, 1);" line151="        control.waitMicros(10);" line152="        pins.digitalWritePin(trig, 0);" line153="" line154="        // read pulse" line155="        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);" line156="" line157="        switch (unit) {" line158="            case PingUnit.Centimeters: return Math.idiv(d, 58);" line159="            case PingUnit.Inches: return Math.idiv(d, 148);" line160="            default: return d;" line161="        }" line162="    }" line163="" line164="    /**" line165="    * toggle led" line166="    */" line167="    //% blockId=LEDR block=&quot;红色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line168="    //% brightness.min=0 brightness.max=1023" line169="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line170="    //% expandableArgumentMode=&quot;toggle&quot;" line171="    //% subcategory=执行器" line172="    export function ledRBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line173="        if (ledstate) {" line174="            pins.analogSetPeriod(pin, 1023)" line175="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line176="        }" line177="        else {" line178="            pins.analogWritePin(pin, 1023)" line179="            brightness = 1023" line180="        }" line181="    }" line182="" line183="    /**" line184="    * toggle led" line185="    */" line186="    //% blockId=LEDG block=&quot;绿色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line187="    //% brightness.min=0 brightness.max=1023" line188="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line189="    //% expandableArgumentMode=&quot;toggle&quot;" line190="    //% subcategory=执行器" line191="    export function ledGBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line192="        if (ledstate) {" line193="            pins.analogSetPeriod(pin, 1023)" line194="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line195="        }" line196="        else {" line197="            pins.analogWritePin(pin, 1023)" line198="            brightness = 1023" line199="        }" line200="    }" line201="" line202="    /**" line203="    * toggle led" line204="    */" line205="    //% blockId=LEDB block=&quot;蓝色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line206="    //% brightness.min=0 brightness.max=1023" line207="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line208="    //% expandableArgumentMode=&quot;toggle&quot;" line209="    //% subcategory=执行器" line210="    export function ledBBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line211="        if (ledstate) {" line212="            pins.analogSetPeriod(pin, 1023)" line213="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line214="        }" line215="        else {" line216="            pins.analogWritePin(pin, 1023)" line217="            brightness = 1023" line218="        }" line219="    }" line220="" line221="    /**" line222="    * toggle led" line223="    */" line224="    //% blockId=LEDY block=&quot;黄色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;" line225="    //% brightness.min=0 brightness.max=1023" line226="    //% ledstate.shadow=&quot;toggleOnOff&quot;" line227="    //% expandableArgumentMode=&quot;toggle&quot;" line228="    //% subcategory=执行器" line229="    export function ledYBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {" line230="        if (ledstate) {" line231="            pins.analogSetPeriod(pin, 1023)" line232="            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))" line233="        }" line234="        else {" line235="            pins.analogWritePin(pin, 1023)" line236="            brightness = 1023" line237="        }" line238="    }" line239="" line240="    const PCA9685_ADD = 0x40" line241="    const MODE1 = 0x00" line242="    const LED0_ON_L = 0x06" line243="    const PRESCALE = 0xFE" line244="" line245="    let initialized = false" line246="" line247="    export enum enPos {" line248="        //% blockId=&quot;forward&quot; block=&quot;前进&quot;" line249="        forward = 1," line250="        //% blockId=&quot;stop&quot; block=&quot;后退&quot;" line251="        stop = 2" line252="    }" line253="" line254="    export enum enServo {" line255="        S1 = 0," line256="        S2," line257="        S3," line258="        S4" line259="    }" line260="" line261="    export enum enMotors {" line262="        M1 = 8," line263="        M2 = 10," line264="        M3 = 12," line265="        M4 = 14" line266="    }" line267="" line268="    function i2cwrite(addr: number, reg: number, value: number) {" line269="        let buf = pins.createBuffer(2)" line270="        buf[0] = reg" line271="        buf[1] = value" line272="        pins.i2cWriteBuffer(addr, buf)" line273="    }" line274="" line275="    function i2cread(addr: number, reg: number) {" line276="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line277="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line278="        return val;" line279="    }" line280="" line281="    function initPCA9685(): void {" line282="        i2cwrite(PCA9685_ADD, MODE1, 0x00)" line283="        setFreq(50);" line284="    }" line285="" line286="    function setFreq(freq: number): void {" line287="        // Constrain the frequency" line288="        let prescaleval = 25000000;" line289="        prescaleval /= 4096;" line290="        prescaleval /= freq;" line291="        prescaleval -= 1;" line292="        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);" line293="        let oldmode = i2cread(PCA9685_ADD, MODE1);" line294="        let newmode = (oldmode &amp; 0x7F) | 0x10; // sleep" line295="        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep" line296="        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler" line297="        i2cwrite(PCA9685_ADD, MODE1, oldmode);" line298="        control.waitMicros(5000);" line299="        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);" line300="    }" line301="" line302="    function setPwm(channel: number, on: number, off: number): void {" line303="        if (channel &lt; 0 || channel &gt; 15)" line304="            return;" line305="        if (!initialized) {" line306="            initPCA9685();" line307="        }" line308="        let buf2 = pins.createBuffer(5);" line309="        buf2[0] = LED0_ON_L + 4 * channel;" line310="        buf2[1] = on &amp; 0xff;" line311="        buf2[2] = (on &gt;&gt; 8) &amp; 0xff;" line312="        buf2[3] = off &amp; 0xff;" line313="        buf2[4] = (off &gt;&gt; 8) &amp; 0xff;" line314="        pins.i2cWriteBuffer(PCA9685_ADD, buf2);" line315="    }" line316="" line317="    //% blockId=SuperBit_Servo4 block=&quot;Geek舵机| %num|角度 %value&quot;" line318="    //% num.min=1 num.max=4 value.min=0 value.max=300" line319="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=20" line320="    //% subcategory=执行器" line321="    export function Servo4(num: enServo, value: number): void {" line322="" line323="        // 50hz: 20,000 us" line324="        let us = (value * 1800 * 0.6 / 180 + 600); // 0.6 ~ 2.4" line325="        let pwm = us * 4096 / 20000;" line326="        setPwm(num, 0, pwm);" line327="" line328="    }" line329="" line330="    //% blockId=SuperBit_MotorRun block=&quot;电机|%index|速度(-255~255) %speed&quot;" line331="    //% speed.min=-255 speed.max=255" line332="    //% subcategory=执行器" line333="    export function MotorRun(index: enMotors, speed: number): void {" line334="        if (!initialized) {" line335="            initPCA9685()" line336="        }" line337="        speed = speed * 16; // map 255 to 4096" line338="        if (speed &gt;= 4096) {" line339="            speed = 4095" line340="        }" line341="        if (speed &lt;= -4096) {" line342="            speed = -4095" line343="        }" line344="" line345="        let a = index" line346="        let b = index + 1" line347="" line348="        if (a &gt; 10) {" line349="            if (speed &gt;= 0) {" line350="                setPwm(a, 0, speed)" line351="                setPwm(b, 0, 0)" line352="            } else {" line353="                setPwm(a, 0, 0)" line354="                setPwm(b, 0, -speed)" line355="            }" line356="        }" line357="        else {" line358="            if (speed &gt;= 0) {" line359="                setPwm(b, 0, speed)" line360="                setPwm(a, 0, 0)" line361="            } else {" line362="                setPwm(b, 0, 0)" line363="                setPwm(a, 0, -speed)" line364="            }" line365="        }" line366="    }" line367="" line368="    //% blockId=&quot;elecmagnet&quot; block=&quot;电磁铁 %pin 切换至 %magState || 磁力 %force&quot;" line369="    //% magState.shadow=&quot;toggleOnOff&quot;" line370="    //% force.min=0 force.max=1023" line371="    //% expandableArgumentMode=&quot;toggle&quot;" line372="    //% subcategory=执行器" line373="    export function elecmagnet(pin: AnalogPin, magState: boolean, force: number = 1023): void {" line374="" line375="        if (magState) {" line376="            pins.analogSetPeriod(pin, 1023)" line377="            pins.analogWritePin(pin, Math.map(force, 0, 1023, 0, 1023))" line378="        }" line379="        else {" line380="            pins.analogWritePin(pin, 0)" line381="            force = 0" line382="        }" line383="    }" line384="    //% blockId=&quot;pinpullup&quot; block=&quot;巡线传感器 %pin 引脚为上拉&quot;" line385="    //% subcategory=执行器" line386="    export function pinpullup(pin: PINs): void {" line387="        switch (pin) {" line388="            case PINs.P0: pins.setPull(DigitalPin.P0, PinPullMode.PullUp);" line389="            case PINs.P1: pins.setPull(DigitalPin.P1, PinPullMode.PullUp);" line390="            case PINs.P2: pins.setPull(DigitalPin.P2, PinPullMode.PullUp);" line391="            case PINs.P3: pins.setPull(DigitalPin.P3, PinPullMode.PullUp);" line392="            case PINs.P4: pins.setPull(DigitalPin.P4, PinPullMode.PullUp);" line393="            case PINs.P5: pins.setPull(DigitalPin.P5, PinPullMode.PullUp);" line394="            case PINs.P6: pins.setPull(DigitalPin.P6, PinPullMode.PullUp);" line395="            case PINs.P7: pins.setPull(DigitalPin.P7, PinPullMode.PullUp);" line396="            case PINs.P8: pins.setPull(DigitalPin.P8, PinPullMode.PullUp);" line397="            case PINs.P9: pins.setPull(DigitalPin.P9, PinPullMode.PullUp);" line398="            case PINs.P10: pins.setPull(DigitalPin.P10, PinPullMode.PullUp);" line399="            case PINs.P11: pins.setPull(DigitalPin.P11, PinPullMode.PullUp);" line400="            case PINs.P12: pins.setPull(DigitalPin.P12, PinPullMode.PullUp);" line401="            case PINs.P13: pins.setPull(DigitalPin.P13, PinPullMode.PullUp);" line402="            case PINs.P14: pins.setPull(DigitalPin.P14, PinPullMode.PullUp);" line403="            case PINs.P15: pins.setPull(DigitalPin.P15, PinPullMode.PullUp);" line404="            case PINs.P16: pins.setPull(DigitalPin.P16, PinPullMode.PullUp);" line405="            case PINs.P19: pins.setPull(DigitalPin.P19, PinPullMode.PullUp);" line406="            case PINs.P20: pins.setPull(DigitalPin.P20, PinPullMode.PullUp);" line407="        }" line408="" line409="" line410="    }" line411="" line412="    //% blockId=&quot;laser_controller&quot; block=&quot;激光 %pin 切换至 %laserState || 激光 %intensity&quot;" line413="    //% laserState.shadow=&quot;toggleOnOff&quot;" line414="    //% intensity.min=0 intensity.max=1023" line415="    //% expandableArgumentMode=&quot;toggle&quot;" line416="    //% subcategory=执行器" line417="    export function laserController(pin: AnalogPin, laserState: boolean, intensity: number = 1023): void {" line418="" line419="        if (laserState) {" line420="            pins.analogSetPeriod(pin, 1023)" line421="            pins.analogWritePin(pin, Math.map(intensity, 0, 1023, 0, 1023))" line422="        }" line423="        else {" line424="            pins.analogWritePin(pin, 0)" line425="            intensity = 0" line426="        }" line427="    }" line428="" line429="    //% blockId=&quot;octopus_ReadWaterLevel&quot; block=&quot;水位传感器 %waterlevelpin&quot;" line430="    //% subcategory=传感器" line431="    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {" line432="        let voltage4 = 0;" line433="        let waterLevel = 0;" line434="        voltage4 = pins.map(" line435="            pins.analogReadPin(waterlevelpin)," line436="            0," line437="            1023," line438="            0," line439="            1023" line440="        );" line441="        waterLevel = voltage4;" line442="        return Math.round(waterLevel);" line443="    }" line444="" line445="    //% blockId=&quot;ReadGasConcentration&quot; block=&quot;可燃气体传感器 %gasconcentrationpin&quot;" line446="    //% subcategory=传感器" line447="    export function ReadGasConcentration(gasconcentrationpin: AnalogPin): number {" line448="        let voltage5 = 0;" line449="        let gasConcentration = 0;" line450="        voltage5 = pins.map(" line451="            pins.analogReadPin(gasconcentrationpin)," line452="            0," line453="            1023," line454="            0," line455="            1023" line456="        );" line457="        gasConcentration = voltage5;" line458="        return Math.round(gasConcentration);" line459="    }" line460="" line461="    //% blockId=&quot;Readflame&quot; block=&quot;火焰传感器 %flamepin&quot;" line462="    //% subcategory=传感器" line463="    export function Readflame(flamepin: AnalogPin): number {" line464="        let voltage6 = 0;" line465="        let flame = 0;" line466="        voltage6 = pins.map(" line467="            pins.analogReadPin(flamepin)," line468="            0," line469="            1023," line470="            0," line471="            1023" line472="        );" line473="        flame = voltage6;" line474="        return Math.round(flame);" line475="    }" line476="" line477="    //% blockId=&quot;ReadGrayLevel&quot; block=&quot;灰度传感器 %graylevelpin&quot;" line478="    //% subcategory=传感器" line479="    export function ReadGrayLevel(graylevelpin: AnalogPin): number {" line480="        let voltage7 = 0;" line481="        let grayLevel = 0;" line482="        voltage7 = pins.map(" line483="            pins.analogReadPin(graylevelpin)," line484="            0," line485="            1023," line486="            80," line487="            1023" line488="        );" line489="        grayLevel = voltage7;" line490="        return Math.round(grayLevel);" line491="    }" line492="" line493="    //% blockId=&quot;readWaterTemp&quot; block=&quot;防水温度传感器 %waterproofpin&quot;" line494="    //% subcategory=传感器" line495="    export function readWaterTemp(waterproofpin: AnalogPin): number {" line496="        let voltage22 = 0;" line497="        let waterProofTemp = 0;" line498="        voltage22 = pins.analogReadPin(waterproofpin);//%获得原始值" line499="        if (voltage22 &gt; 1001) { waterProofTemp = 100; }" line500="        else if (voltage22 &gt; 1000) { waterProofTemp = 98; }" line501="        else if (voltage22 &gt; 999) { waterProofTemp = 97; }" line502="        else if (voltage22 &gt; 998) { waterProofTemp = 96; }" line503="        else if (voltage22 &gt; 997) { waterProofTemp = 95; }" line504="        else if (voltage22 &gt; 996) { waterProofTemp = 93; }" line505="        else if (voltage22 &gt; 995) { waterProofTemp = 92; }" line506="        else if (voltage22 &gt; 994) { waterProofTemp = 91; }" line507="        else if (voltage22 &gt; 993) { waterProofTemp = 90; }" line508="        else if (voltage22 &gt; 992) { waterProofTemp = 89; }" line509="        else if (voltage22 &gt; 991) { waterProofTemp = 88; }" line510="        else if (voltage22 &gt; 990) { waterProofTemp = 87; }" line511="        else if (voltage22 &gt; 989) { waterProofTemp = 86; }" line512="        else if (voltage22 &gt; 988) { waterProofTemp = 85; }" line513="        else if (voltage22 &gt; 987) { waterProofTemp = 84; }" line514="        else if (voltage22 &gt; 986) { waterProofTemp = 83; }" line515="        else if (voltage22 &gt; 985) { waterProofTemp = 82; }" line516="        else if (voltage22 &gt; 984) { waterProofTemp = 81; }" line517="        else if (voltage22 &gt; 982) { waterProofTemp = 80; }" line518="        else if (voltage22 &gt; 981) { waterProofTemp = 79; }" line519="        else if (voltage22 &gt; 980) { waterProofTemp = 78; }" line520="        else if (voltage22 &gt; 978) { waterProofTemp = 77; }" line521="        else if (voltage22 &gt; 977) { waterProofTemp = 76; }" line522="        else if (voltage22 &gt; 975) { waterProofTemp = 75; }" line523="        else if (voltage22 &gt; 974) { waterProofTemp = 74; }" line524="        else if (voltage22 &gt; 972) { waterProofTemp = 73; }" line525="        else if (voltage22 &gt; 971) { waterProofTemp = 72; }" line526="        else if (voltage22 &gt; 969) { waterProofTemp = 71; }" line527="        else if (voltage22 &gt; 967) { waterProofTemp = 70; }" line528="        else if (voltage22 &gt; 965) { waterProofTemp = 69; }" line529="        else if (voltage22 &gt; 963) { waterProofTemp = 68; }" line530="        else if (voltage22 &gt; 961) { waterProofTemp = 67; }" line531="        else if (voltage22 &gt; 959) { waterProofTemp = 66; }" line532="        else if (voltage22 &gt; 957) { waterProofTemp = 65; }" line533="        else if (voltage22 &gt; 955) { waterProofTemp = 64; }" line534="        else if (voltage22 &gt; 953) { waterProofTemp = 63; }" line535="        else if (voltage22 &gt; 950) { waterProofTemp = 62; }" line536="        else if (voltage22 &gt; 948) { waterProofTemp = 61; }" line537="        else if (voltage22 &gt; 943) { waterProofTemp = 59; }" line538="        else if (voltage22 &gt; 940) { waterProofTemp = 58; }" line539="        else if (voltage22 &gt; 937) { waterProofTemp = 57; }" line540="        else if (voltage22 &gt; 934) { waterProofTemp = 56; }" line541="        else if (voltage22 &gt; 931) { waterProofTemp = 55; }" line542="        else if (voltage22 &gt; 928) { waterProofTemp = 54; }" line543="        else if (voltage22 &gt; 924) { waterProofTemp = 53; }" line544="        else if (voltage22 &gt; 921) { waterProofTemp = 52; }" line545="        else if (voltage22 &gt; 917) { waterProofTemp = 51; }" line546="        else if (voltage22 &gt; 914) { waterProofTemp = 51; }" line547="        else if (voltage22 &gt; 910) { waterProofTemp = 49; }" line548="        else if (voltage22 &gt; 906) { waterProofTemp = 48; }" line549="        else if (voltage22 &gt; 902) { waterProofTemp = 47; }" line550="        else if (voltage22 &gt; 898) { waterProofTemp = 46; }" line551="        else if (voltage22 &gt; 893) { waterProofTemp = 45; }" line552="        else if (voltage22 &gt; 889) { waterProofTemp = 44; }" line553="        else if (voltage22 &gt; 884) { waterProofTemp = 43; }" line554="        else if (voltage22 &gt; 879) { waterProofTemp = 42; }" line555="        else if (voltage22 &gt; 874) { waterProofTemp = 41; }" line556="        else if (voltage22 &gt; 869) { waterProofTemp = 40; }" line557="        else if (voltage22 &gt; 864) { waterProofTemp = 39; }" line558="        else if (voltage22 &gt; 858) { waterProofTemp = 38; }" line559="        else if (voltage22 &gt; 852) { waterProofTemp = 37; }" line560="        else if (voltage22 &gt; 846) { waterProofTemp = 36; }" line561="        else if (voltage22 &gt; 840) { waterProofTemp = 35; }" line562="        else if (voltage22 &gt; 834) { waterProofTemp = 34; }" line563="        else if (voltage22 &gt; 827) { waterProofTemp = 33; }" line564="        else if (voltage22 &gt; 821) { waterProofTemp = 32; }" line565="        else if (voltage22 &gt; 814) { waterProofTemp = 31; }" line566="        else if (voltage22 &gt; 806) { waterProofTemp = 30; }" line567="        else if (voltage22 &gt; 799) { waterProofTemp = 29; }" line568="        else if (voltage22 &gt; 791) { waterProofTemp = 28; }" line569="        else if (voltage22 &gt; 784) { waterProofTemp = 27; }" line570="        else if (voltage22 &gt; 776) { waterProofTemp = 26; }" line571="        else if (voltage22 &gt; 767) { waterProofTemp = 25; }" line572="        else if (voltage22 &gt; 759) { waterProofTemp = 24; }" line573="        else if (voltage22 &gt; 750) { waterProofTemp = 23; }" line574="        else if (voltage22 &gt; 741) { waterProofTemp = 22; }" line575="        else if (voltage22 &gt; 732) { waterProofTemp = 21; }" line576="        else if (voltage22 &gt; 713) { waterProofTemp = 19; }" line577="        else if (voltage22 &gt; 703) { waterProofTemp = 18; }" line578="        else if (voltage22 &gt; 692) { waterProofTemp = 17; }" line579="        else if (voltage22 &gt; 682) { waterProofTemp = 16; }" line580="        else if (voltage22 &gt; 671) { waterProofTemp = 15; }" line581="        else if (voltage22 &gt; 661) { waterProofTemp = 14; }" line582="        else if (voltage22 &gt; 650) { waterProofTemp = 13; }" line583="        else if (voltage22 &gt; 638) { waterProofTemp = 12; }" line584="        else if (voltage22 &gt; 627) { waterProofTemp = 11; }" line585="        else if (voltage22 &gt; 615) { waterProofTemp = 10; }" line586="        else if (voltage22 &gt; 604) { waterProofTemp = 9; }" line587="        else if (voltage22 &gt; 592) { waterProofTemp = 8; }" line588="        else if (voltage22 &gt; 579) { waterProofTemp = 7; }" line589="        else if (voltage22 &gt; 567) { waterProofTemp = 6; }" line590="        else if (voltage22 &gt; 555) { waterProofTemp = 5; }" line591="        else if (voltage22 &gt; 542) { waterProofTemp = 4; }" line592="        else if (voltage22 &gt; 530) { waterProofTemp = 3; }" line593="        else if (voltage22 &gt; 517) { waterProofTemp = 2; }" line594="        else if (voltage22 &gt; 504) { waterProofTemp = 1; }" line595="        else { waterProofTemp = 0; }" line596="        return waterProofTemp;" line597="    }" line598="" line599="    //% blockId=potentiometerRead" line600="    //% block=&quot;电位器 %pin&quot;" line601="    //% subcategory=传感器" line602="    export function potentiometerRead(pin: AnalogPin): number {" line603="        return pins.analogReadPin(pin);" line604="    }" line605="" line606="    //% blockId=buttonState" line607="    //% block=&quot;按钮传感器 %pin&quot;" line608="    //% subcategory=传感器" line609="    export function buttonState(pin: DigitalPin): number {" line610="" line611="        return pins.digitalReadPin(pin);" line612="    }" line613="    //% blockId=followState" line614="    //% block=&quot;巡线传感器 %pin&quot;" line615="    //% subcategory=传感器" line616="    export function followState(pin: PINs): number {" line617="        switch (pin) {" line618="            case PINs.P0: return pins.digitalReadPin(DigitalPin.P0);" line619="            case PINs.P1: return pins.digitalReadPin(DigitalPin.P1);" line620="            case PINs.P2: return pins.digitalReadPin(DigitalPin.P2);" line621="            case PINs.P3: return pins.digitalReadPin(DigitalPin.P3);" line622="            case PINs.P4: return pins.digitalReadPin(DigitalPin.P4);" line623="            case PINs.P5: return pins.digitalReadPin(DigitalPin.P5);" line624="            case PINs.P6: return pins.digitalReadPin(DigitalPin.P6);" line625="            case PINs.P7: return pins.digitalReadPin(DigitalPin.P7);" line626="            case PINs.P8: return pins.digitalReadPin(DigitalPin.P8);" line627="            case PINs.P9: return pins.digitalReadPin(DigitalPin.P9);" line628="            case PINs.P10: return pins.digitalReadPin(DigitalPin.P10);" line629="            case PINs.P11: return pins.digitalReadPin(DigitalPin.P11);" line630="            case PINs.P12: return pins.digitalReadPin(DigitalPin.P12);" line631="            case PINs.P13: return pins.digitalReadPin(DigitalPin.P13);" line632="            case PINs.P14: return pins.digitalReadPin(DigitalPin.P14);" line633="            case PINs.P15: return pins.digitalReadPin(DigitalPin.P15);" line634="            case PINs.P16: return pins.digitalReadPin(DigitalPin.P16);" line635="            case PINs.P19: return pins.digitalReadPin(DigitalPin.P19);" line636="            case PINs.P20: return pins.digitalReadPin(DigitalPin.P20);" line637="" line638="        }" line639="" line640="    }" line641="" line642="    //% blockId=farState" line643="    //% block=&quot;远距离光电传感器 %pin&quot;" line644="    //% subcategory=传感器" line645="    export function farState(pin: DigitalPin): number {" line646="        return pins.digitalReadPin(pin);" line647="    }" line648="" line649="    //% blockId=hState" line650="    //% block=&quot;霍尔传感器 %pin&quot;" line651="    //% subcategory=传感器" line652="    export function hState(pin: DigitalPin): number {" line653="        return pins.digitalReadPin(pin);" line654="    }" line655="" line656="    enum LCS_Constants {" line657="        // Constants" line658="        ADDRESS = 0x29," line659="        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727." line660="" line661="        COMMAND_BIT = 0x80," line662="" line663="        ENABLE = 0x00," line664="        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable" line665="        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer" line666="        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it" line667="        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it" line668="        ATIME = 0x01, // Integration time" line669="        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)" line670="        AILTL = 0x04, // Clear channel lower interrupt threshold" line671="        AILTH = 0x05," line672="        AIHTL = 0x06, // Clear channel upper interrupt threshold" line673="        AIHTH = 0x07," line674="        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts" line675="        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt" line676="        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt" line677="        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt" line678="        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt" line679="        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt" line680="        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt" line681="        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt" line682="        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt" line683="        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt" line684="        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt" line685="        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt" line686="        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt" line687="        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt" line688="        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt" line689="        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt" line690="        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt" line691="        CONFIG = 0x0D," line692="        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME" line693="        CONTROL = 0x0F, // Set the gain level for the sensor" line694="        STATUS = 0x13," line695="        STATUS_AINT = 0x10, // RGBC Clean channel interrupt" line696="        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle" line697="" line698="        CDATAL = 0x14, // Clear channel data" line699="        CDATAH = 0x15," line700="        RDATAL = 0x16, // Red channel data" line701="        RDATAH = 0x17," line702="        GDATAL = 0x18, // Green channel data" line703="        GDATAH = 0x19," line704="        BDATAL = 0x1A, // Blue channel data" line705="        BDATAH = 0x1B," line706="" line707="        GAIN_1X = 0x00, //  1x gain" line708="        GAIN_4X = 0x01, //  4x gain" line709="        GAIN_16X = 0x02, // 16x gain" line710="        GAIN_60X = 0x03  // 60x gain" line711="    }" line712="" line713="    let LCS_integration_time_val = 0" line714="" line715="    // I2C functions" line716="" line717="    function I2C_WriteReg8(addr: number, reg: number, val: number) {" line718="        let buf3 = pins.createBuffer(2)" line719="        buf3.setNumber(NumberFormat.UInt8BE, 0, reg)" line720="        buf3.setNumber(NumberFormat.UInt8BE, 1, val)" line721="        pins.i2cWriteBuffer(addr, buf3)" line722="    }" line723="" line724="    function I2C_ReadReg8(addr: number, reg: number): number {" line725="        let buf4 = pins.createBuffer(1)" line726="        buf4.setNumber(NumberFormat.UInt8BE, 0, reg)" line727="        pins.i2cWriteBuffer(addr, buf4)" line728="        buf4 = pins.i2cReadBuffer(addr, 1)" line729="        return buf4.getNumber(NumberFormat.UInt8BE, 0);" line730="    }" line731="" line732="    function I2C_ReadReg16(addr: number, reg: number): number {" line733="        let buf5 = pins.createBuffer(1)" line734="        buf5.setNumber(NumberFormat.UInt8BE, 0, reg)" line735="        pins.i2cWriteBuffer(addr, buf5)" line736="        buf5 = pins.i2cReadBuffer(addr, 2)" line737="        // Little endian" line738="        return ((buf5.getNumber(NumberFormat.UInt8BE, 1) &lt;&lt; 8) | buf5.getNumber(NumberFormat.UInt8BE, 0));" line739="    }" line740="    function LCS_get_raw_data(delay: boolean = false): number[] {" line741="        if (delay) {" line742="            // Delay for the integration time to allow reading immediately after the previous read." line743="            basic.pause((256 - LCS_integration_time_val) * 2.4)" line744="        }" line745="" line746="        let div = (256 - LCS_integration_time_val) * 1024" line747="        let rgbc = [0, 0, 0, 0]" line748="        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div" line749="        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div" line750="        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div" line751="        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div" line752="        if (rgbc[0] &gt; 1) {" line753="            rgbc[0] = 1" line754="        }" line755="        if (rgbc[1] &gt; 1) {" line756="            rgbc[1] = 1" line757="        }" line758="        if (rgbc[2] &gt; 1) {" line759="            rgbc[2] = 1" line760="        }" line761="        if (rgbc[3] &gt; 1) {" line762="            rgbc[3] = 1" line763="        }" line764="        return rgbc" line765="    }" line766="" line767="    let font: number[] = [];" line768="    font[0] = 0x0022d422;" line769="    font[1] = 0x0022d422;" line770="    font[2] = 0x0022d422;" line771="    font[3] = 0x0022d422;" line772="    font[4] = 0x0022d422;" line773="    font[5] = 0x0022d422;" line774="    font[6] = 0x0022d422;" line775="    font[7] = 0x0022d422;" line776="    font[8] = 0x0022d422;" line777="    font[9] = 0x0022d422;" line778="    font[10] = 0x0022d422;" line779="    font[11] = 0x0022d422;" line780="    font[12] = 0x0022d422;" line781="    font[13] = 0x0022d422;" line782="    font[14] = 0x0022d422;" line783="    font[15] = 0x0022d422;" line784="    font[16] = 0x0022d422;" line785="    font[17] = 0x0022d422;" line786="    font[18] = 0x0022d422;" line787="    font[19] = 0x0022d422;" line788="    font[20] = 0x0022d422;" line789="    font[21] = 0x0022d422;" line790="    font[22] = 0x0022d422;" line791="    font[23] = 0x0022d422;" line792="    font[24] = 0x0022d422;" line793="    font[25] = 0x0022d422;" line794="    font[26] = 0x0022d422;" line795="    font[27] = 0x0022d422;" line796="    font[28] = 0x0022d422;" line797="    font[29] = 0x0022d422;" line798="    font[30] = 0x0022d422;" line799="    font[31] = 0x0022d422;" line800="    font[32] = 0x00000000;" line801="    font[33] = 0x000002e0;" line802="    font[34] = 0x00018060;" line803="    font[35] = 0x00afabea;" line804="    font[36] = 0x00aed6ea;" line805="    font[37] = 0x01991133;" line806="    font[38] = 0x010556aa;" line807="    font[39] = 0x00000060;" line808="    font[40] = 0x000045c0;" line809="    font[41] = 0x00003a20;" line810="    font[42] = 0x00051140;" line811="    font[43] = 0x00023880;" line812="    font[44] = 0x00002200;" line813="    font[45] = 0x00021080;" line814="    font[46] = 0x00000100;" line815="    font[47] = 0x00111110;" line816="    font[48] = 0x0007462e;" line817="    font[49] = 0x00087e40;" line818="    font[50] = 0x000956b9;" line819="    font[51] = 0x0005d629;" line820="    font[52] = 0x008fa54c;" line821="    font[53] = 0x009ad6b7;" line822="    font[54] = 0x008ada88;" line823="    font[55] = 0x00119531;" line824="    font[56] = 0x00aad6aa;" line825="    font[57] = 0x0022b6a2;" line826="    font[58] = 0x00000140;" line827="    font[59] = 0x00002a00;" line828="    font[60] = 0x0008a880;" line829="    font[61] = 0x00052940;" line830="    font[62] = 0x00022a20;" line831="    font[63] = 0x0022d422;" line832="    font[64] = 0x00e4d62e;" line833="    font[65] = 0x000f14be;" line834="    font[66] = 0x000556bf;" line835="    font[67] = 0x0008c62e;" line836="    font[68] = 0x0007463f;" line837="    font[69] = 0x0008d6bf;" line838="    font[70] = 0x000094bf;" line839="    font[71] = 0x00cac62e;" line840="    font[72] = 0x000f909f;" line841="    font[73] = 0x000047f1;" line842="    font[74] = 0x0017c629;" line843="    font[75] = 0x0008a89f;" line844="    font[76] = 0x0008421f;" line845="    font[77] = 0x01f1105f;" line846="    font[78] = 0x01f4105f;" line847="    font[79] = 0x0007462e;" line848="    font[80] = 0x000114bf;" line849="    font[81] = 0x000b6526;" line850="    font[82] = 0x010514bf;" line851="    font[83] = 0x0004d6b2;" line852="    font[84] = 0x0010fc21;" line853="    font[85] = 0x0007c20f;" line854="    font[86] = 0x00744107;" line855="    font[87] = 0x01f4111f;" line856="    font[88] = 0x000d909b;" line857="    font[89] = 0x00117041;" line858="    font[90] = 0x0008ceb9;" line859="    font[91] = 0x0008c7e0;" line860="    font[92] = 0x01041041;" line861="    font[93] = 0x000fc620;" line862="    font[94] = 0x00010440;" line863="    font[95] = 0x01084210;" line864="    font[96] = 0x00000820;" line865="    font[97] = 0x010f4a4c;" line866="    font[98] = 0x0004529f;" line867="    font[99] = 0x00094a4c;" line868="    font[100] = 0x000fd288;" line869="    font[101] = 0x000956ae;" line870="    font[102] = 0x000097c4;" line871="    font[103] = 0x0007d6a2;" line872="    font[104] = 0x000c109f;" line873="    font[105] = 0x000003a0;" line874="    font[106] = 0x0006c200;" line875="    font[107] = 0x0008289f;" line876="    font[108] = 0x000841e0;" line877="    font[109] = 0x01e1105e;" line878="    font[110] = 0x000e085e;" line879="    font[111] = 0x00064a4c;" line880="    font[112] = 0x0002295e;" line881="    font[113] = 0x000f2944;" line882="    font[114] = 0x0001085c;" line883="    font[115] = 0x00012a90;" line884="    font[116] = 0x010a51e0;" line885="    font[117] = 0x010f420e;" line886="    font[118] = 0x00644106;" line887="    font[119] = 0x01e8221e;" line888="    font[120] = 0x00093192;" line889="    font[121] = 0x00222292;" line890="    font[122] = 0x00095b52;" line891="    font[123] = 0x0008fc80;" line892="    font[124] = 0x000003e0;" line893="    font[125] = 0x000013f1;" line894="    font[126] = 0x00841080;" line895="    font[127] = 0x0022d422;" line896="" line897="    let _I2CAddr = 0;" line898="    let _screen = pins.createBuffer(1025);" line899="    let _buf2 = pins.createBuffer(2);" line900="    let _buf3 = pins.createBuffer(3);" line901="    let _buf4 = pins.createBuffer(4);" line902="    let _ZOOM = 1;" line903="" line904="    function cmd1(d: number) {" line905="        let n = d % 256;" line906="        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);" line907="    }" line908="" line909="    function cmd2(d1: number, d2: number) {" line910="        _buf3[0] = 0;" line911="        _buf3[1] = d1;" line912="        _buf3[2] = d2;" line913="        pins.i2cWriteBuffer(_I2CAddr, _buf3);" line914="    }" line915="" line916="    function cmd3(d1: number, d2: number, d3: number) {" line917="        _buf4[0] = 0;" line918="        _buf4[1] = d1;" line919="        _buf4[2] = d2;" line920="        _buf4[3] = d3;" line921="        pins.i2cWriteBuffer(_I2CAddr, _buf4);" line922="    }" line923="" line924="    function set_pos(col: number = 0, page: number = 0) {" line925="        cmd1(0xb0 | page) // page number" line926="        let c = col * (_ZOOM + 1)" line927="        cmd1(0x00 | (c % 16)) // lower start column address" line928="        cmd1(0x10 | (c &gt;&gt; 4)) // upper start column address    " line929="    }" line930="" line931="    // clear bit" line932="    function clrbit(d: number, b: number): number {" line933="        if (d &amp; (1 &lt;&lt; b))" line934="            d -= (1 &lt;&lt; b)" line935="        return d" line936="    }" line937="" line938="    /**" line939="     * show text in OLED" line940="     * @param x is X alis, eg: 0" line941="     * @param y is Y alis, eg: 0" line942="     * @param s is the text will be show, eg: 'Hello!'" line943="     */" line944="    //% blockId=&quot;OLED12864_I2C_SHOWSTRING1&quot; block=&quot;显示 文本 在 x %x|y %y|文本 %s&quot;" line945="    //% parts=OLED12864_I2C trackArgs=0" line946="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line947="    //% weight=80 blockGap=10 color=#0855AA" line948="    export function showString(x: number, y: number, s: string, color: number = 1) {" line949="        let col2 = 0" line950="        let q = 0" line951="        let ind2 = 0" line952="        for (let r = 0; r &lt; s.length; r++) {" line953="            q = font[s.charCodeAt(r)]" line954="            for (let k = 0; k &lt; 5; k++) {" line955="                col2 = 0" line956="                for (let l = 0; l &lt; 5; l++) {" line957="                    if (q &amp; (1 &lt;&lt; (5 * k + l)))" line958="                        col2 |= (1 &lt;&lt; (l + 1))" line959="                }" line960="                ind2 = (x + r) * 5 * (_ZOOM + 1) + y * 128 + k * (_ZOOM + 1) + 1" line961="                if (color == 0)" line962="                    col2 = 255 - col2" line963="                _screen[ind2] = col2" line964="                if (_ZOOM)" line965="                    _screen[ind2 + 1] = col2" line966="            }" line967="        }" line968="        set_pos(x * 5, y)" line969="        let ind02 = x * 5 * (_ZOOM + 1) + y * 128" line970="        let buf7 = _screen.slice(ind02, ind2 + 1)" line971="        buf7[0] = 0x40" line972="        pins.i2cWriteBuffer(_I2CAddr, buf7)" line973="    }" line974="" line975="    /**" line976="     * show a number in OLED" line977="     * @param x is X alis, eg: 0" line978="     * @param y is Y alis, eg: 0" line979="     * @param num is the number will be show, eg: 12" line980="     * @param color is number color, eg: 1" line981="     */" line982="    //% blockId=&quot;OLED12864_I2C_NUMBER&quot; block=&quot;显示 数字 在 x %x|y %y|数字 %num&quot;" line983="    //% parts=OLED12864_I2C trackArgs=0" line984="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line985="    //% weight=80 blockGap=10 color=#0855AA" line986="    export function showNumber(x: number, y: number, num: number, color: number = 1) {" line987="        showString(x, y, num.toString(), color)" line988="    }" line989="" line990="" line991="    export function draw() {" line992="        set_pos()" line993="        pins.i2cWriteBuffer(_I2CAddr, _screen)" line994="    }" line995="" line996="    /**" line997="     * clear screen" line998="     */" line999="    //% blockId=&quot;OLED12864_I2C_CLEAR&quot; block=&quot;清除&quot;" line1000="    //% parts=OLED12864_I2C trackArgs=0" line1001="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1002="    //% weight=63 blockGap=10 color=#0855AA" line1003="    export function clear() {" line1004="        _screen.fill(0)" line1005="        _screen[0] = 0x40" line1006="        draw()" line1007="    }" line1008="" line1009="    /**" line1010="     * OLED initialize" line1011="     * @param addr is i2c addr, eg: 60" line1012="     */" line1013="    //% blockId=&quot;OLED12864_I2C_init&quot; block=&quot;初始化 OLED 地址为 %addr&quot;" line1014="    //% parts=OLED12864_I2C trackArgs=0" line1015="    //% weight=85 blockGap=10" line1016="    //% group=&quot;OLED显示屏&quot; subcategory=执行器" line1017="    //% blockGap=10  color=#0855AA" line1018="    export function init(addr: number) {" line1019="        _I2CAddr = addr;" line1020="        cmd1(0xAE)       // SSD1306_DISPLAYOFF" line1021="        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME" line1022="        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV" line1023="        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX" line1024="        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET" line1025="        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE" line1026="        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP" line1027="        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE" line1028="        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR" line1029="        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR" line1030="        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP" line1031="        cmd1(0xc8)       // SSD1306_COMSCANDEC" line1032="        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS" line1033="        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST" line1034="        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE" line1035="        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT" line1036="        cmd1(0xA6)       // SSD1306_NORMALDISPLAY" line1037="        cmd2(0xD6, 1)    // zoom on" line1038="        cmd1(0xAF)       // SSD1306_DISPLAYON" line1039="        clear()" line1040="        _ZOOM = 1" line1041="    }" line1042="" line1043="    /**" line1044="     * A NeoPixel strip" line1045="     */" line1046="    export class Strip {" line1047="        buf: Buffer;" line1048="        pin: DigitalPin;" line1049="        // TODO: encode as bytes instead of 32bit" line1050="        brightness: number;" line1051="        start: number; // start offset in LED strip" line1052="        _length: number; // number of LEDs" line1053="        _mode: NeoPixelMode;" line1054="        _matrixWidth: number; // number of leds in a matrix - if any" line1055="" line1056="        /**" line1057="         * Shows all LEDs to a given color (range 0-255 for r, g, b)." line1058="         * @param rgb RGB color of the LED" line1059="         */" line1060="        //% blockId=&quot;neopixel_set_strip_color&quot; block=&quot;%strip|显示 颜色 %rgb=neopixel_colors&quot;" line1061="        //% strip.defl=strip" line1062="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1063="        //% color=#2699BF blockGap=10" line1064="        showColor(rgb: number) {" line1065="            rgb = rgb &gt;&gt; 0;" line1066="            this.setAllRGB(rgb);" line1067="            this.show();" line1068="        }" line1069="" line1070="        /**" line1071="         * Shows a rainbow pattern on all LEDs." line1072="         * @param startHue the start hue value for the rainbow, eg: 1" line1073="         * @param endHue the end hue value for the rainbow, eg: 360" line1074="         */" line1075="        //% blockId=&quot;neopixel_set_strip_rainbow&quot; block=&quot;%strip|显示 彩虹 从 %startHue|到 %endHue&quot;" line1076="        //% strip.defl=strip" line1077="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot; " line1078="        //% color=#2699BF blockGap=10" line1079="        showRainbow(startHue: number = 1, endHue: number = 360) {" line1080="            if (this._length &lt;= 0) return;" line1081="" line1082="            startHue = startHue &gt;&gt; 0;" line1083="            endHue = endHue &gt;&gt; 0;" line1084="            const saturation = 100;" line1085="            const luminance = 50;" line1086="            const steps = this._length;" line1087="            const direction = HueInterpolationDirection.Clockwise;" line1088="" line1089="            //hue" line1090="            const h1 = startHue;" line1091="            const h2 = endHue;" line1092="            const hDistCW = ((h2 + 360) - h1) % 360;" line1093="            const hStepCW = Math.idiv((hDistCW * 100), steps);" line1094="            const hDistCCW = ((h1 + 360) - h2) % 360;" line1095="            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);" line1096="            let hStep: number;" line1097="            if (direction === HueInterpolationDirection.Clockwise) {" line1098="                hStep = hStepCW;" line1099="            } else if (direction === HueInterpolationDirection.CounterClockwise) {" line1100="                hStep = hStepCCW;" line1101="            } else {" line1102="                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;" line1103="            }" line1104="            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation" line1105="" line1106="            //sat" line1107="            const s1 = saturation;" line1108="            const s2 = saturation;" line1109="            const sDist = s2 - s1;" line1110="            const sStep = Math.idiv(sDist, steps);" line1111="            const s1_100 = s1 * 100;" line1112="" line1113="            //lum" line1114="            const l1 = luminance;" line1115="            const l2 = luminance;" line1116="            const lDist = l2 - l1;" line1117="            const lStep = Math.idiv(lDist, steps);" line1118="            const l1_100 = l1 * 100" line1119="" line1120="            //interpolate" line1121="            if (steps === 1) {" line1122="                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))" line1123="            } else {" line1124="                this.setPixelColor(0, hsl(startHue, saturation, luminance));" line1125="                for (let t = 1; t &lt; steps - 1; t++) {" line1126="                    const u = Math.idiv((h1_100 + t * hStep), 100) + 360;" line1127="                    const v = Math.idiv((s1_100 + t * sStep), 100);" line1128="                    const w = Math.idiv((l1_100 + t * lStep), 100);" line1129="                    this.setPixelColor(t, hsl(u, v, w));" line1130="                }" line1131="                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));" line1132="            }" line1133="            this.show();" line1134="        }" line1135="" line1136="" line1137="        /**" line1138="         * Set LED to a given color (range 0-255 for r, g, b)." line1139="         * You need to call ``show`` to make the changes visible." line1140="         * @param pixeloffset position of the NeoPixel in the strip,eg: 1" line1141="         * @param rgb RGB color of the LED" line1142="         */" line1143="        //% blockId=&quot;neopixel_set_pixel_color&quot; block=&quot;%strip|设置 像素 颜色 在 %pixeloffset|到 %rgb=neopixel_colors&quot;" line1144="        //% strip.defl=strip" line1145="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1146="        //% color=#2699BF blockGap=10" line1147="        setPixelColor(pixeloffset: number, rgb: number): void {" line1148="            this.setPixelRGB(pixeloffset &gt;&gt; 0, rgb &gt;&gt; 0);" line1149="        }" line1150="" line1151="        /**" line1152="         * Send all the changes to the strip." line1153="         */" line1154="        //% blockId=&quot;neopixel_show&quot; block=&quot;%strip|显示&quot;" line1155="        //% strip.defl=strip" line1156="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1157="        //% color=#2699BF blockGap=10" line1158="        show() {" line1159="            // only supported in beta" line1160="            // ws2812b.setBufferMode(this.pin, this._mode);" line1161="            ws2812b.sendBuffer(this.buf, this.pin);" line1162="        }" line1163="" line1164="        /**" line1165="         * Turn off all LEDs." line1166="         * You need to call ``show`` to make the changes visible." line1167="         */" line1168="        //% blockId=&quot;neopixel_clear&quot; block=&quot;%strip|清除&quot;" line1169="        //% strip.defl=strip" line1170="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1171="        //% color=#2699BF blockGap=10" line1172="        clear(): void {" line1173="            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1174="            this.buf.fill(0, this.start * stride, this._length * stride);" line1175="        }" line1176="" line1177="        /**" line1178="         * Set the brightness of the strip. This flag only applies to future operation." line1179="         * @param brightness a measure of LED brightness in 0-255. eg: 255" line1180="         */" line1181="        //% blockId=&quot;neopixel_set_brightness&quot; block=&quot;%strip|设置 亮度 %brightness&quot;" line1182="        //% strip.defl=strip" line1183="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1184="        //% color=#2699BF blockGap=10" line1185="        setBrightness(brightness: number): void {" line1186="            this.brightness = brightness &amp; 0xff;" line1187="        }" line1188="" line1189="        /**" line1190="         * Set the pin where the neopixel is connected, defaults to P0." line1191="         */" line1192="        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1193="        //% color=#2699BF blockGap=10" line1194="        setPin(pin: DigitalPin): void {" line1195="            this.pin = pin;" line1196="            pins.digitalWritePin(this.pin, 0);" line1197="            // don't yield to avoid races on initialization" line1198="        }" line1199="" line1200="" line1201="" line1202="        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {" line1203="            if (this._mode === NeoPixelMode.RGB_RGB) {" line1204="                this.buf[offset + 0] = red;" line1205="                this.buf[offset + 1] = green;" line1206="            } else {" line1207="                this.buf[offset + 0] = green;" line1208="                this.buf[offset + 1] = red;" line1209="            }" line1210="            this.buf[offset + 2] = blue;" line1211="        }" line1212="" line1213="        private setAllRGB(rgb: number) {" line1214="            let red = unpackR(rgb);" line1215="            let green = unpackG(rgb);" line1216="            let blue = unpackB(rgb);" line1217="" line1218="            const br3 = this.brightness;" line1219="            if (br3 &lt; 255) {" line1220="                red = (red * br3) &gt;&gt; 8;" line1221="                green = (green * br3) &gt;&gt; 8;" line1222="                blue = (blue * br3) &gt;&gt; 8;" line1223="            }" line1224="            const end3 = this.start + this._length;" line1225="            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1226="            for (let i5 = this.start; i5 &lt; end3; ++i5) {" line1227="                this.setBufferRGB(i5 * stride6, red, green, blue)" line1228="            }" line1229="        }" line1230="        private setAllW(white: number) {" line1231="            if (this._mode !== NeoPixelMode.RGBW)" line1232="                return;" line1233="" line1234="            let br4 = this.brightness;" line1235="            if (br4 &lt; 255) {" line1236="                white = (white * br4) &gt;&gt; 8;" line1237="            }" line1238="            let buf8 = this.buf;" line1239="            let end4 = this.start + this._length;" line1240="            for (let i6 = this.start; i6 &lt; end4; ++i6) {" line1241="                let ledoffset3 = i6 * 4;" line1242="                buf8[ledoffset3 + 3] = white;" line1243="            }" line1244="        }" line1245="        private setPixelRGB(pixeloffset: number, rgb: number): void {" line1246="            if (pixeloffset &lt; 0" line1247="                || pixeloffset &gt;= this._length)" line1248="                return;" line1249="" line1250="            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;" line1251="            pixeloffset = (pixeloffset + this.start) * stride7;" line1252="" line1253="            let red2 = unpackR(rgb);" line1254="            let green2 = unpackG(rgb);" line1255="            let blue2 = unpackB(rgb);" line1256="" line1257="            let br5 = this.brightness;" line1258="            if (br5 &lt; 255) {" line1259="                red2 = (red2 * br5) &gt;&gt; 8;" line1260="                green2 = (green2 * br5) &gt;&gt; 8;" line1261="                blue2 = (blue2 * br5) &gt;&gt; 8;" line1262="            }" line1263="            this.setBufferRGB(pixeloffset, red2, green2, blue2)" line1264="        }" line1265="        private setPixelW(pixeloffset: number, white: number): void {" line1266="            if (this._mode !== NeoPixelMode.RGBW)" line1267="                return;" line1268="" line1269="            if (pixeloffset &lt; 0" line1270="                || pixeloffset &gt;= this._length)" line1271="                return;" line1272="" line1273="            pixeloffset = (pixeloffset + this.start) * 4;" line1274="" line1275="            let br6 = this.brightness;" line1276="            if (br6 &lt; 255) {" line1277="                white = (white * br6) &gt;&gt; 8;" line1278="            }" line1279="            let buf9 = this.buf;" line1280="            buf9[pixeloffset + 3] = white;" line1281="        }" line1282="    }" line1283="" line1284="    /**" line1285="     * Create a new NeoPixel driver for `numleds` LEDs." line1286="     * @param pin the pin where the neopixel is connected." line1287="     * @param numleds number of leds in the strip, eg: 8,30,60,64" line1288="     */" line1289="    //% blockId=&quot;neopixel_create&quot; block=&quot;灯环 在 端口 %pin|用 %numleds| leds&quot;" line1290="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1291="    //% trackArgs=0,2" line1292="    //% blockSetVariable=strip" line1293="    //% color=#2699BF blockGap=10" line1294="    //% weight=51" line1295="    export function create(pin: DigitalPin, numleds: number): Strip {" line1296="        let strip2 = new Strip();" line1297="        let stride8 = NeoPixelMode.RGBW ? 4 : 3;" line1298="        strip2.buf = pins.createBuffer(numleds * stride8);" line1299="        strip2.start = 0;" line1300="        strip2._length = numleds;" line1301="        strip2._mode = NeoPixelMode.RGB;" line1302="        strip2._matrixWidth = 0;" line1303="        strip2.setBrightness(128)" line1304="        strip2.setPin(pin)" line1305="        return strip2;" line1306="    }" line1307="" line1308="    /**" line1309="     * Converts red, green, blue channels into a RGB color" line1310="     * @param red value of the red channel between 0 and 255. eg: 255" line1311="     * @param green value of the green channel between 0 and 255. eg: 255" line1312="     * @param blue value of the blue channel between 0 and 255. eg: 255" line1313="     */" line1314="    //% blockId=&quot;neopixel_rgb&quot; block=&quot;红 %red|绿 %green|蓝 %blue&quot;" line1315="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1316="    //% weight=32" line1317="    //% color=#2699BF blockGap=10" line1318="    export function rgb(red: number, green: number, blue: number): number {" line1319="        return packRGB(red, green, blue);" line1320="    }" line1321="" line1322="    /**" line1323="     * Gets the RGB value of a known color" line1324="    */" line1325="    //% blockId=&quot;neopixel_colors&quot; block=&quot;%color&quot;" line1326="    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;" line1327="    //% weight=32" line1328="    //% color=#2699BF blockGap=10" line1329="    export function colors(color: NeoPixelColors): number {" line1330="        return color;" line1331="    }" line1332="" line1333="    function packRGB(a: number, b: number, c: number): number {" line1334="        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);" line1335="    }" line1336="" line1337="    function unpackR(rgb: number): number {" line1338="        let r3 = (rgb &gt;&gt; 16) &amp; 0xFF;" line1339="        return r3;" line1340="    }" line1341="" line1342="    function unpackG(rgb: number): number {" line1343="        let g3 = (rgb &gt;&gt; 8) &amp; 0xFF;" line1344="        return g3;" line1345="    }" line1346="" line1347="    function unpackB(rgb: number): number {" line1348="        let b3 = (rgb) &amp; 0xFF;" line1349="        return b3;" line1350="    }" line1351="" line1352="    export function hsl(h: number, s: number, l: number): number {" line1353="        h = Math.round(h);" line1354="        s = Math.round(s);" line1355="        l = Math.round(l);" line1356="" line1357="        h = h % 360;" line1358="        s = Math.clamp(0, 99, s);" line1359="        l = Math.clamp(0, 99, l);" line1360="        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]" line1361="        let h12 = Math.idiv(h, 60);//[0,6]" line1362="        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]" line1363="        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);" line1364="        let x = (c2 * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color" line1365="        let r$: number;" line1366="        let g$: number;" line1367="        let b$: number;" line1368="        if (h12 == 0) {" line1369="            r$ = c2; g$ = x; b$ = 0;" line1370="        } else if (h12 == 1) {" line1371="            r$ = x; g$ = c2; b$ = 0;" line1372="        } else if (h12 == 2) {" line1373="            r$ = 0; g$ = c2; b$ = x;" line1374="        } else if (h12 == 3) {" line1375="            r$ = 0; g$ = x; b$ = c2;" line1376="        } else if (h12 == 4) {" line1377="            r$ = x; g$ = 0; b$ = c2;" line1378="        } else if (h12 == 5) {" line1379="            r$ = c2; g$ = 0; b$ = x;" line1380="        }" line1381="        let m2 = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c2), 2);" line1382="        let r4 = r$ + m2;" line1383="        let g4 = g$ + m2;" line1384="        let b4 = b$ + m2;" line1385="        return packRGB(r4, g4, b4);" line1386="    }" line1387="" line1388="    export enum HueInterpolationDirection {" line1389="        Clockwise," line1390="        CounterClockwise," line1391="        Shortest" line1392="    }" line1393="}" numlines="1394"></mutation></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>